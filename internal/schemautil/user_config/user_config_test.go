// TODO: Add build tags.

package user_config

import (
	"fmt"
	"strings"
	"testing"

	"github.com/aiven/aiven-go-client/tools/exp/dist"
	"github.com/dave/jennifer/jen"
	"github.com/ettle/strcase"
	"gopkg.in/yaml.v3"
)

// convertPropertyToSchema is a function that converts a property to a Terraform schema.
func convertPropertyToSchema(n string, p map[string]interface{}, t string) jen.Dict {
	r := jen.Dict{
		jen.Id("Type"):     jen.Qual(SchemaPackage, t),
		jen.Id("Optional"): jen.Lit(true),
	}

	if d, ok := p["description"]; ok {
		k := "Description"

		if strings.Contains(strings.ToLower(d.(string)), "deprecated") {
			k = "Deprecated"
		}

		r[jen.Id(k)] = jen.Lit(d)
	} else {
		if title, ok := p["title"]; ok {
			r[jen.Id("Description")] = jen.Lit(title)
		}
	}

	if co, ok := p["create_only"]; ok && co.(bool) {
		r[jen.Id("DiffSuppressFunc")] = jen.Qual(SchemaUtilPackage, "CreateOnlyDiffSuppressFunc")
	}

	if strings.Contains(n, "api_key") || strings.Contains(n, "password") {
		r[jen.Id("Sensitive")] = jen.Lit(true)
	}

	return r
}

// handlePrimitiveTypeProperty is a function that converts a primitive type property to a Terraform schema.
func handlePrimitiveTypeProperty(n string, p map[string]interface{}, t string) *jen.Statement {
	return jen.Values(convertPropertyToSchema(n, p, t))
}

// handleTypeSetProperty is a function that converts a set type property to a Terraform schema.
func handleTypeSetProperty(n string, p map[string]interface{}, t string) *jen.Statement {
	return jen.Values(convertPropertyToSchema(n, p, t))
}

// handleTypeMapProperty is a function that converts a map type property to a Terraform schema.
func handleTypeMapProperty(n string, p map[string]interface{}, t string) *jen.Statement {
	pa, ok := p["properties"].(map[string]interface{})
	if !ok {
		return nil
	}

	r := convertPropertyToSchema(n, p, t)

	s := jen.Map(jen.String()).Op("*").Qual(SchemaPackage, "Schema").Values(convertPropertiesToSchemaMap(pa))

	r[jen.Id("Elem")] = jen.Op("&").Qual(SchemaPackage, "Resource").Values(jen.Dict{
		jen.Id("Schema"): s,
	})

	r[jen.Id("DiffSuppressFunc")] = jen.Qual(SchemaUtilPackage, "EmptyObjectDiffSuppressFuncSkipArrays").Call(s)

	r[jen.Id("MaxItems")] = jen.Lit(1)

	return jen.Values(r)
}

// handleAggregateTypeProperty is a function that converts an aggregate type property to a Terraform schema.
func handleAggregateTypeProperty(n string, p map[string]interface{}, t string) *jen.Statement {
	switch t {
	case "TypeSet":
		return handleTypeSetProperty(n, p, t)
	case "TypeMap":
		return handleTypeMapProperty(n, p, t)
	default:
		panic("unknown aggregate type")
	}
}

// convertPropertiesToSchemaMap is a function that converts a map of properties to a map of Terraform schemas.
func convertPropertiesToSchemaMap(p map[string]interface{}) jen.Dict {
	r := make(jen.Dict, len(p))

	for k, v := range p {
		va, ok := v.(map[string]interface{})
		if !ok {
			continue
		}

		t := terraformTypes(slicedString(va["type"]))

		for _, vn := range t {
			var s *jen.Statement

			switch vn {
			case "TypeBool", "TypeInt", "TypeFloat", "TypeString":
				s = handlePrimitiveTypeProperty(k, va, vn)
			default:
				s = handleAggregateTypeProperty(k, va, vn)
			}

			if s == nil {
				continue
			}

			r[jen.Lit(k)] = s
		}
	}

	return r
}

// generateSchema is a function that generates Terraform schema via its map representation.
func generateSchema(n string, m map[string]interface{}) {
	np := fmt.Sprintf("%ss", n)

	f := jen.NewFile("user_config")

	f.HeaderComment("Code generated by internal/schemautil/user_config/user_config_test.go; DO NOT EDIT.")

	for k, v := range m {
		kp := strcase.ToGoPascal(k)

		va, ok := v.(map[string]interface{})
		if !ok {
			continue
		}

		pa, ok := va["properties"].(map[string]interface{})
		if !ok {
			continue
		}

		fn := fmt.Sprintf("%s%s", n, kp)

		f.Commentf("%s is a generated function returning the schema of the %s %s.", fn, k, n)

		f.
			Func().
			Id(fn).
			Params().
			Id("*schema.Schema").
			Block(
				jen.Id("s").Op(":=").Map(jen.String()).Op("*").Qual(SchemaPackage, "Schema").Values(convertPropertiesToSchemaMap(pa)),

				jen.Line(),

				jen.Return(
					jen.Op("&").Qual(SchemaPackage, "Schema").Values(jen.Dict{
						jen.Id("Type"):             jen.Qual(SchemaPackage, "TypeList"),
						jen.Id("Description"):      jen.Lit(fmt.Sprintf("%s user configurable settings", kp)),
						jen.Id("Elem"):             jen.Op("&").Qual(SchemaPackage, "Resource").Values(jen.Dict{jen.Id("Schema"): jen.Id("s")}),
						jen.Id("Optional"):         jen.Lit(true),
						jen.Id("DiffSuppressFunc"): jen.Qual(SchemaUtilPackage, "EmptyObjectDiffSuppressFuncSkipArrays").Call(jen.Id("s")),
						jen.Id("MaxItems"):         jen.Lit(1),
					}),
				),
			).
			Line()
	}

	if err := f.Save(fmt.Sprintf("%s.go", strcase.ToSnake(np))); err != nil {
		panic(err)
	}
}

// representationToMap converts a YAML representation of a Terraform schema to a map.
func representationToMap(r []byte) map[string]interface{} {
	var m map[string]interface{}

	if err := yaml.Unmarshal(r, &m); err != nil {
		panic(err)
	}

	return m
}

// TestMain is the entry point for the user config schema generator.
func TestMain(m *testing.M) {
	generateSchema("ServiceType", representationToMap(dist.ServiceTypes))

	generateSchema("IntegrationType", representationToMap(dist.IntegrationTypes))

	generateSchema("IntegrationEndpointType", representationToMap(dist.IntegrationEndpointTypes))
}
